# pypypy

Все графики находятся в handle.ipynb

В первом задании 


"переиспользовать код класса Dice в классе ThreeDicePool": Вместо Dice будем наследоваться от полностью виртуального класса AbstractDice, состояющего из деструктора (строка 5) и virtual метода roll (строка 6) Это необходимо, чтобы потом все остальные наследующиеся классы могли перегрузить метод roll так, как им нужно Переиспользование состоит во-первых в наследовании от AbstractDice (строка 22) и том, что теперь ThreeDicePool не инициализирует новые Dice для собственного пользования, а получает уже три готовых объекта Dice в качестве аргументов

"использовать только одну реализацию функции expected_value на основе полиморфизам подтипов": Поскольку все используемые классы (такие как Dice и ThreeDicePool) наследуются от одного и того же родительского AbstractDice, то в аргумент функции expected_value можно беспрепятственно передавать, что Dice, что ThreeDicePool (хотя с виду это и два различных типа данных)

"использовать класс ThreeDicePool для любого класса, реализующего метод .roll, на основе полиморфизма подтипов": На строке 48 мы иницилиазируем ThreeDicePool, передавая ему в конструктор три только что созданных Dice (alpha, beta и gamma)


Абстрактный класс AbstractDice:
Этот класс описывает общий интерфейс для кубиков. В нём определён чисто виртуальный метод roll(), который должен быть реализован в каждом классе-наследнике. Это позволяет полиморфно работать с различными типами кубиков (например, обычным кубиком или набором из трёх кубиков).


Класс Dice:
Класс моделирует обычный кубик с количеством граней max. Генерация случайных чисел осуществляется с использованием библиотеки <random>. Метод roll() возвращает случайное число от 1 до max.


Класс ThreeDicePool:
Класс описывает набор из трёх кубиков. В его конструктор передаются объекты, которые реализуют интерфейс AbstractDice (в данном случае это три объекта Dice). Метод roll() возвращает сумму результатов бросков трёх кубиков.


Функция expected_value():
Функция вычисляет математическое ожидание для любого объекта, реализующего метод roll. В аргументы передаётся объект типа AbstractDice, что позволяет использовать функцию как для одиночных кубиков, так и для набора кубиков (например, ThreeDicePool).


Главная функция main():
В этой части программы демонстрируется использование классов и функция для вычисления математического ожидания. Сначала создаются три кубика с разными начальными значениями для генераторов случайных чисел. Затем эти кубики передаются в ThreeDicePool, который бросает их и суммирует результаты.


Во втором задании

Класс PenaltyDice:

Этот класс моделирует бросок кубика с "штрафом", то есть выбирает минимальное значение из двух бросков.
Класс BonusDice:

Этот класс моделирует бросок кубика с "преимуществом", то есть выбирает максимальное значение из двух бросков.
Функция value_probabilty():

Эта функция вычисляет вероятность того, что при броске кубика выпадет заданное значение value, путём многократного повторения бросков.
Функция expected_value():

Функция вычисляет среднее значение (математическое ожидание) для переданного кубика после заданного количества бросков.
Главная программа:

В программе создаются несколько кубиков и реализуются различные их вариации с использованием штрафа и преимущества. Результаты вычислений математического ожидания и вероятностей записываются в файл second.csv для последующего анализа.

В третьем задании

Виртуальное наследование от AbstractDice:

Классы PenaltyDice и BonusDice используют виртуальное наследование от базового класса AbstractDice. Это решает проблему ромбовидного наследования, когда класс-наследник (DoubleDice) может иметь несколько копий одного и того же базового класса. Виртуальное наследование гарантирует, что будет использоваться только одна копия AbstractDice.
Класс DoubleDice:

Этот класс наследует одновременно от PenaltyDice и BonusDice, а также использует один и тот же объект кубика, передаваемый в конструктор. В методе roll() вычисляется среднее значение между минимальным (из PenaltyDice) и максимальным (из BonusDice) результатами.
Таким образом, класс сочетает оба подхода — штраф и преимущество.
Функция expected_value():

Эта функция вычисляет математическое ожидание для любого объекта, реализующего интерфейс AbstractDice, выполняя многократные броски кубика.
Функция value_probabilty():

Эта функция вычисляет вероятность попадания в заданное значение после нескольких бросков кубика.
Пример использования в main():

Создаётся обычный кубик (Dice) и передаётся в объект DoubleDice, который использует как штраф (минимум из двух бросков), так и преимущество (максимум из двух бросков). Программа вычисляет математическое ожидание и записывает вероятности для различных значений в файл.
